"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAll = void 0;
const utils_js_1 = require("../utils.js");
const headers_js_1 = require("./headers.js");
const operation_js_1 = require("./operation.js");
const paths_js_1 = require("./paths.js");
const request_js_1 = require("./request.js");
const responses_js_1 = require("./responses.js");
const schema_js_1 = require("./schema.js");
function transformAll(schema, ctx) {
    const readonly = (0, utils_js_1.tsReadonly)(ctx.immutableTypes);
    let output = {};
    let operations = {};
    if (ctx.rawSchema) {
        const required = new Set(Object.keys(schema));
        switch (ctx.version) {
            case 2: {
                output.definitions = (0, schema_js_1.transformSchemaObjMap)(schema, { ...ctx, required });
                return output;
            }
            case 3: {
                output.schemas = (0, schema_js_1.transformSchemaObjMap)(schema, { ...ctx, required });
                return output;
            }
        }
    }
    output.paths = "";
    if (schema.paths) {
        output.paths += (0, paths_js_1.transformPathsObj)(schema.paths, {
            ...ctx,
            globalParameters: (schema.components && schema.components.parameters) || schema.parameters,
            operations,
        });
    }
    switch (ctx.version) {
        case 2: {
            if (schema.definitions) {
                output.definitions = (0, schema_js_1.transformSchemaObjMap)(schema.definitions, {
                    ...ctx,
                    required: new Set(Object.keys(schema.definitions)),
                });
            }
            if (schema.parameters) {
                output.parameters = (0, schema_js_1.transformSchemaObjMap)(schema.parameters, {
                    ...ctx,
                    required: new Set(Object.keys(schema.parameters)),
                });
            }
            if (schema.responses) {
                output.responses = (0, responses_js_1.transformResponsesObj)(schema.responses, ctx);
            }
            break;
        }
        case 3: {
            output.components = "";
            if (schema.components) {
                if (schema.components.schemas) {
                    output.components += `  ${readonly}schemas: {\n    ${(0, schema_js_1.transformSchemaObjMap)(schema.components.schemas, {
                        ...ctx,
                        required: new Set(Object.keys(schema.components.schemas)),
                    })}\n  }\n`;
                }
                if (schema.components.responses) {
                    output.components += `  ${readonly}responses: {\n    ${(0, responses_js_1.transformResponsesObj)(schema.components.responses, ctx)}\n  }\n`;
                }
                if (schema.components.parameters) {
                    output.components += `  ${readonly}parameters: {\n    ${(0, schema_js_1.transformSchemaObjMap)(schema.components.parameters, {
                        ...ctx,
                        required: new Set(Object.keys(schema.components.parameters)),
                    })}\n  }\n`;
                }
                if (schema.components.requestBodies) {
                    output.components += `  ${readonly}requestBodies: {\n    ${(0, request_js_1.transformRequestBodies)(schema.components.requestBodies, ctx)}\n  }\n`;
                }
                if (schema.components.headers) {
                    output.components += `  ${readonly}headers: {\n    ${(0, headers_js_1.transformHeaderObjMap)(schema.components.headers, {
                        ...ctx,
                        required: new Set(),
                    })}\n  }\n`;
                }
            }
            break;
        }
    }
    output.operations = "";
    if (Object.keys(operations).length) {
        for (const id of Object.keys(operations)) {
            const { operation, pathItem } = operations[id];
            if (operation.description)
                output.operations += (0, utils_js_1.comment)(operation.description);
            output.operations += `  ${readonly}"${id}": {\n    ${(0, operation_js_1.transformOperationObj)(operation, {
                ...ctx,
                pathItem,
                globalParameters: (schema.components && schema.components.parameters) || schema.parameters,
            })}\n  }\n`;
        }
    }
    for (const k of Object.keys(output)) {
        if (typeof output[k] === "string") {
            output[k] = output[k].trim();
        }
    }
    return output;
}
exports.transformAll = transformAll;
//# sourceMappingURL=index.js.map