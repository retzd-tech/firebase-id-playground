import path from "path";
import * as color from "kleur/colors";
import prettier from "prettier";
import parserTypescript from "prettier/parser-typescript.js";
import { URL } from "url";
import load, { resolveSchema, VIRTUAL_JSON_URL } from "./load.js";
import { swaggerVersion } from "./utils.js";
import { transformAll } from "./transform/index.js";
export * from "./types.js";
export const WARNING_MESSAGE = `/**
* This file was auto-generated by openapi-typescript.
* Do not make direct changes to the file.
*/


`;
async function openapiTS(schema, options = {}) {
    const ctx = {
        additionalProperties: options.additionalProperties || false,
        auth: options.auth,
        defaultNonNullable: options.defaultNonNullable || false,
        formatter: options && typeof options.formatter === "function" ? options.formatter : undefined,
        immutableTypes: options.immutableTypes || false,
        rawSchema: options.rawSchema || false,
        version: options.version || 3,
    };
    let rootSchema = {};
    let external = {};
    const allSchemas = {};
    if (typeof schema === "string") {
        const schemaURL = resolveSchema(schema);
        if (options.silent === false)
            console.log(color.yellow(`üî≠ Loading spec from ${color.bold(schemaURL.href)}‚Ä¶`));
        await load(schemaURL, {
            ...ctx,
            schemas: allSchemas,
            rootURL: schemaURL,
            httpHeaders: options.httpHeaders,
            httpMethod: options.httpMethod,
        });
        for (const k of Object.keys(allSchemas)) {
            if (k === schemaURL.href) {
                rootSchema = allSchemas[k];
            }
            else {
                external[k] = allSchemas[k];
            }
        }
    }
    else {
        await load(schema, {
            ...ctx,
            schemas: allSchemas,
            rootURL: new URL(VIRTUAL_JSON_URL),
            httpHeaders: options.httpHeaders,
            httpMethod: options.httpMethod,
        });
        for (const k of Object.keys(allSchemas)) {
            if (k === VIRTUAL_JSON_URL) {
                rootSchema = allSchemas[k];
            }
            else {
                external[k] = allSchemas[k];
            }
        }
    }
    let output = WARNING_MESSAGE;
    if (!(options === null || options === void 0 ? void 0 : options.version) && !ctx.rawSchema)
        ctx.version = swaggerVersion(rootSchema);
    const rootTypes = transformAll(rootSchema, { ...ctx });
    for (const k of Object.keys(rootTypes)) {
        if (typeof rootTypes[k] === "string") {
            output += `export interface ${k} {\n  ${rootTypes[k]}\n}\n\n`;
        }
    }
    output += `export interface external {\n`;
    const externalKeys = Object.keys(external);
    externalKeys.sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
    for (const subschemaURL of externalKeys) {
        output += `  "${subschemaURL}": {\n`;
        const subschemaTypes = transformAll(external[subschemaURL], { ...ctx, namespace: subschemaURL });
        for (const k of Object.keys(subschemaTypes)) {
            output += `    "${k}": {\n      ${subschemaTypes[k]}\n    }\n`;
        }
        output += `  }\n`;
    }
    output += `}\n\n`;
    let prettierOptions = {
        parser: "typescript",
        plugins: [parserTypescript],
    };
    if (options && options.prettierConfig) {
        try {
            const userOptions = await prettier.resolveConfig(path.resolve(process.cwd(), options.prettierConfig));
            prettierOptions = {
                ...(userOptions || {}),
                ...prettierOptions,
                plugins: [...prettierOptions.plugins, ...((userOptions && userOptions.plugins) || [])],
            };
        }
        catch (err) {
            console.error(`‚ùå ${err}`);
        }
    }
    return prettier.format(output, prettierOptions);
}
export default openapiTS;
//# sourceMappingURL=index.js.map